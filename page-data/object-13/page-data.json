{"componentChunkName":"component---src-templates-blog-post-js","path":"/object-13/","result":{"data":{"site":{"siteMetadata":{"title":"지은이의 개발 Blog","author":"Jieun Hong"}},"markdownRemark":{"id":"17c48b99-0ebc-582c-81cd-f7dc2834cea6","html":"<p>상속의 두 가지 용도</p>\n<ol>\n<li>\n<p>타입 계층을 구현하는 것</p>\n<ul>\n<li>부모클래스는 일반적인 개념을 구현하고 (일반화)</li>\n<li>자식클래스는 특수한 개념을 구현한다 (특수화)</li>\n</ul>\n</li>\n<li>\n<p>코드 재사용</p>\n<ul>\n<li>부모, 자식 클래스가 강하게 결합되어 변경하기 어려운 코드를 얻게될 수 있음</li>\n</ul>\n<p>상속의 목표는 코드 재사용이 아니라 타입 계층을 구현하는 것 이어야 한다.</p>\n<p><strong>객체기반 프로그래밍(Object-Based Programming)</strong> </p>\n<ul>\n<li>상태와 행동을 캡슐화한 객체를 조합하여 프로그램을 구성하는 방식</li>\n<li>비주얼 베이직</li>\n</ul>\n<p><strong>객체지향 프로그래밍(Object-Oriented-Programming)</strong></p>\n<ul>\n<li>객체기반 프로그래밍의 한 종류</li>\n<li>상속과 다형성을 지원한다는 점에서 다름</li>\n<li>자바, 루비, C#</li>\n</ul>\n<p><strong>프로토타입 기반 언어(Prototype-Based Language)</strong></p>\n<ul>\n<li>객체기반 프로그래밍이 다른 의미로 사용될 때가 있음</li>\n<li>클래스가 존재하지 않는 프로그래밍 방식</li>\n<li>이 때에는 객체기반 프로그래밍이 클래스 없이 객체 만을 사용하는 프로그래밍 방식을 가리킴</li>\n</ul>\n<h2 id=\"1-타입\"><a href=\"#1-%ED%83%80%EC%9E%85\" aria-hidden class=\"anchor\"><svg aria-hidden=\"true\" height=\"16\" version=\"1.1\" viewBox=\"0 0 16 16\" width=\"16\"><path fill-rule=\"evenodd\" d=\"M4 9h1v1H4c-1.5 0-3-1.69-3-3.5S2.55 3 4 3h4c1.45 0 3 1.69 3 3.5 0 1.41-.91 2.72-2 3.25V8.59c.58-.45 1-1.27 1-2.09C10 5.22 8.98 4 8 4H4c-.98 0-2 1.22-2 2.5S3 9 4 9zm9-3h-1v1h1c1 0 2 1.22 2 2.5S13.98 12 13 12H9c-.98 0-2-1.22-2-2.5 0-.83.42-1.64 1-2.09V6.25c-1.09.53-2 1.84-2 3.25C6 11.31 7.55 13 9 13h4c1.45 0 3-1.69 3-3.5S14.5 6 13 6z\"></path></svg></a>1. <strong>타입</strong></h2>\n<p>개념 관점의 타입</p>\n<ul>\n<li>인지하는 세상의 사물의 종류, 인식하는 객체 들에 적용된 개념이나 아이디어</li>\n<li>예를 들어, 자바, 루비, 파이썬은 프로그래밍 언어라고 부른다. 이것은 프로그래밍 언어 타입</li>\n<li>자바, 루비, 파이썬은 프로그래밍 언어라는 타입에 속하기 때문에 인스턴스 라고 불림( = 객체 )</li>\n</ul>\n</li>\n</ol>\n<p>심볼 - 타입에 이름을 붙인 것 = 프로그래밍 언어</p>\n<p>내연 - 타입의 정의, 객체들이 가지는 공통 속성과 행동</p>\n<p>외연 - 타입에 속하는 객체들의 집합 = 자바, 루비, 파이썬 등</p>\n<p>프로그래밍 언어 관점의 타입</p>\n<ul>\n<li>연속적인 비트묶음에 의미와 제약을 부여하기 위해 사용</li>\n<li>\n<p>목적</p>\n<ul>\n<li>\n<p>타임에 수행될 수 있는 유효한 오퍼레이션의 집합을 정의한다.</p>\n<ul>\n<li>자바에서 +는 원시 숫자 또는 문자열 객체는 가능하지만 다른 클래스는 안됨</li>\n<li>객체지향 언어들은 객체의 타입에 따라 적용 가능한 연산자의 종류를 제한함으로써 프로그래머의 실수를 막아준다.</li>\n</ul>\n</li>\n<li>\n<p>타입에 수행되는 오퍼레이션에 대해 미리 약속된 문맥을 제공한다.</p>\n<ul>\n<li>\n<ul>\n<li>연산의 대상 타입에 따라 정수형은 합친 숫자를 보여주고, 문자열은 문장을 이어줌</li>\n</ul>\n</li>\n<li>부여된 타입에 따라 오퍼레이션이 다름</li>\n</ul>\n</li>\n</ul>\n</li>\n<li>타입은 적용 가능한 오퍼레이션의 종류와 의미를 정의함으로써 코드의 의미를 명확하게 전달하고, 개발자의 실수를 방지한다.</li>\n</ul>\n<p>객체지향 패러다임 관점의 타입</p>\n<ul>\n<li>개념관점에서 타입이란 공통의 특징을 공유하는 대상들의 분류다.</li>\n<li>프로그래밍 언어 관점에서 타입은 동일한 오퍼레이션을 적용할 수 있는 인스턴스들의 집합이다.</li>\n<li>객체지향 패러다임 관점에서 오퍼레이션은 객체가 수신할 수 있는 메세지를 의미한다. 따라서 객체의 타입이란 객체가 수신할 수 있는 메세지의 종류를 정의하는 것이다.</li>\n<li>메세지의 집합 = 퍼블릭 인터페이스</li>\n<li>결국 객체의 퍼블릭 인터페이스가 객체의 타입을 결정한다. 따라서 동일한 퍼블릭 인터페이스를 제공하는 객체들은 동일한 타입으로 분류된다.</li>\n</ul>\n<h2 id=\"2-타입-계층\"><a href=\"#2-%ED%83%80%EC%9E%85-%EA%B3%84%EC%B8%B5\" aria-hidden class=\"anchor\"><svg aria-hidden=\"true\" height=\"16\" version=\"1.1\" viewBox=\"0 0 16 16\" width=\"16\"><path fill-rule=\"evenodd\" d=\"M4 9h1v1H4c-1.5 0-3-1.69-3-3.5S2.55 3 4 3h4c1.45 0 3 1.69 3 3.5 0 1.41-.91 2.72-2 3.25V8.59c.58-.45 1-1.27 1-2.09C10 5.22 8.98 4 8 4H4c-.98 0-2 1.22-2 2.5S3 9 4 9zm9-3h-1v1h1c1 0 2 1.22 2 2.5S13.98 12 13 12H9c-.98 0-2-1.22-2-2.5 0-.83.42-1.64 1-2.09V6.25c-1.09.53-2 1.84-2 3.25C6 11.31 7.55 13 9 13h4c1.45 0 3-1.69 3-3.5S14.5 6 13 6z\"></path></svg></a>2. 타입 계층</h2>\n<p>타입 사이의 포함관계</p>\n<ul>\n<li>타입은 외연 관점에서는 더 크고, 내연 관점에서는 더 일반적이다.</li>\n<li>포함되는 타입은 외연 관점에서는 더 적고 내연 관점에서는 더 특수하다.</li>\n<li>일반화와 특수화 관계가 존재한다.</li>\n</ul>\n<p>\n  <a\n    class=\"gatsby-resp-image-link\"\n    href=\"/static/5398dfc91f27361adfb247c405a6c7f5/f3c12/0.png\"\n    style=\"display: block\"\n    target=\"_blank\"\n    rel=\"noopener\"\n  >\n  \n  <span\n    class=\"gatsby-resp-image-wrapper\"\n    style=\"position: relative; display: block;  max-width: 590px; margin-left: auto; margin-right: auto;\"\n  >\n    <span\n      class=\"gatsby-resp-image-background-image\"\n      style=\"padding-bottom: 46.621621621621614%; position: relative; bottom: 0; left: 0; background-image: url('data:image/png;base64,iVBORw0KGgoAAAANSUhEUgAAABQAAAAJCAYAAAAywQxIAAAACXBIWXMAAAsTAAALEwEAmpwYAAABEUlEQVR42pWSC2+DMAyE+f+/cKu0la5AgBJIeCRAgJvtiamPad0snQQOOt/nEG3bhmfiWtcVy7J89+7fd0V/NXTOwTQN4viIw+sL0uQMYxps6z8Mr2uaRrRti6q6IDl/oLUWXdfdfPerIRcjLUv4SmeMmI6jh/eenicybGUI44cQnhu6YRDM4/ubqKlrDNRjWRrASU+nGHWtYa352fC6RkrCKTRhqixDT4jOO0nuKbVzg6TnAZyYK7o3m+cZfd/LwotcEZIlRCeYjM071LqS9CHMNwEeEu6YbKSyFEplYsBmrCLPkaWJnOV0xukffptkdCj9gOpSyr5qrVGVJcpCCSr3+WJ48XwpM6GxGJH7e7Jdn2EZvbHURVVEAAAAAElFTkSuQmCC'); background-size: cover; display: block;\"\n    >\n      <img\n        class=\"gatsby-resp-image-image\"\n        style=\"width: 100%; height: 100%; margin: 0; vertical-align: middle; position: absolute; top: 0; left: 0; box-shadow: inset 0px 0px 0px 400px white;\"\n        alt=\"Untitled\"\n        title=\"\"\n        src=\"/static/5398dfc91f27361adfb247c405a6c7f5/fcda8/0.png\"\n        srcset=\"/static/5398dfc91f27361adfb247c405a6c7f5/12f09/0.png 148w,\n/static/5398dfc91f27361adfb247c405a6c7f5/e4a3f/0.png 295w,\n/static/5398dfc91f27361adfb247c405a6c7f5/fcda8/0.png 590w,\n/static/5398dfc91f27361adfb247c405a6c7f5/f3c12/0.png 764w\"\n        sizes=\"(max-width: 590px) 100vw, 590px\"\n      />\n    </span>\n  </span>\n  \n  </a>\n    </p>\n<p>슈퍼타입 : 더 일반적인 타입 (부모)</p>\n<ul>\n<li>집합이 다른 집합의 모든 멤버를 포함한다.</li>\n<li>타입 정의가 다른 타입보다 좀 더 일반적이다.</li>\n</ul>\n<p>서브타입 : 더 특수한 타입 (자식)</p>\n<ul>\n<li>집합에 포함되는 인스턴스들이 더 큰 집합에 포함된다.</li>\n<li>타입 정의가 다른 타입보다 좀 더 구체적이다.</li>\n</ul>\n<p>객체 정의를 의미하는 내연관점에서 일반화란 어떤 타입의 정의를 좀 더 보편적이고 추상적으로 만드는 과정</p>\n<p>특수화란 어떤 타입의 정의를 좀 더 구체적이고 문맥 종속적으로 만드는 과정</p>\n<p>집합을 의미하는 외연의 관점에서 일반적인 타입의 인스턴스 집합은 특수한 타입의 인스턴스 집합을 포함하는 슈퍼셋이다. </p>\n<p>반대로 특수한 타입의 인스턴스 집한은 일반적인 타입의 인스턴스 집합에 포함된 서브셋이다. </p>\n<p>따라서 특수한 타입에 속한 인스턴스는 동시에 더 일반적인 타입의 인스턴스 이기도 하다.</p>\n<p>일반화 : 다른 타입을 완전히 포함하거나 내포하는 타입을 식별하는 행위 또는 그 행위의 결과</p>\n<p>특수화 : 다른 타입에 안에 전체적으로 포함되거나 완전히 내포되는 타입을 식별하는 행위 또는 그 행위의 결과</p>\n<p><strong>객체지향 프로그래밍과 타입계층</strong></p>\n<p>퍼블릭 인터페이스 관점에서 </p>\n<p>슈퍼타입 : 서브타입이 정의한 퍼블릭 인터페이스를 일반화시켜 상대적으로 범용적으로 넓은 의미로 정의한 것</p>\n<p>서브타입 : 슈퍼타입이 정의한 퍼블릭 인터페이스를 특수화시켜 상대적으로 구체적이고 좁은 의미로 정의한 것</p>\n<p><strong>서브타입의 인스턴스는 슈퍼타입의 인스턴스로 간주될 수 있다.</strong></p>\n<h2 id=\"3-서브클래싱과-서브타이핑\"><a href=\"#3-%EC%84%9C%EB%B8%8C%ED%81%B4%EB%9E%98%EC%8B%B1%EA%B3%BC-%EC%84%9C%EB%B8%8C%ED%83%80%EC%9D%B4%ED%95%91\" aria-hidden class=\"anchor\"><svg aria-hidden=\"true\" height=\"16\" version=\"1.1\" viewBox=\"0 0 16 16\" width=\"16\"><path fill-rule=\"evenodd\" d=\"M4 9h1v1H4c-1.5 0-3-1.69-3-3.5S2.55 3 4 3h4c1.45 0 3 1.69 3 3.5 0 1.41-.91 2.72-2 3.25V8.59c.58-.45 1-1.27 1-2.09C10 5.22 8.98 4 8 4H4c-.98 0-2 1.22-2 2.5S3 9 4 9zm9-3h-1v1h1c1 0 2 1.22 2 2.5S13.98 12 13 12H9c-.98 0-2-1.22-2-2.5 0-.83.42-1.64 1-2.09V6.25c-1.09.53-2 1.84-2 3.25C6 11.31 7.55 13 9 13h4c1.45 0 3-1.69 3-3.5S14.5 6 13 6z\"></path></svg></a>3. 서브클래싱과 서브타이핑</h2>\n<p>언제상속을 사용해야 하는가?</p>\n<ul>\n<li>상속 관계가 is-a 관계를 모델링하는가?</li>\n<li>\n<p>클라이언트 입장에서 부모클래스의 타입으로 자식클래스를 사용해도 무방한가?</p>\n<ul>\n<li>클라이언트 입장에서는 부모클래스와 자식클래스의 차이점을 몰라야 한다. (행동호환성)</li>\n</ul>\n</li>\n</ul>\n<p>is - a 관계</p>\n<ul>\n<li>펭귄은 새이지만 날 수는 없다.</li>\n<li>따라서 어휘적인 정의가 아니라 기대되는 행동에 따라 타입계층을 구성해야 한다.</li>\n</ul>\n<p>행동호환성</p>\n<ul>\n<li>행동이 호환되어야 한다.</li>\n<li>클라이언트 관점에서 행동의 호환여부를 판단</li>\n</ul>\n<p>클라이언트의 기대에 따라 계층 분리하기</p>\n<p>\n  <a\n    class=\"gatsby-resp-image-link\"\n    href=\"/static/911c911a91f9bb20d324ad94526e6406/146da/1.png\"\n    style=\"display: block\"\n    target=\"_blank\"\n    rel=\"noopener\"\n  >\n  \n  <span\n    class=\"gatsby-resp-image-wrapper\"\n    style=\"position: relative; display: block;  max-width: 590px; margin-left: auto; margin-right: auto;\"\n  >\n    <span\n      class=\"gatsby-resp-image-background-image\"\n      style=\"padding-bottom: 26.351351351351354%; position: relative; bottom: 0; left: 0; background-image: url('data:image/png;base64,iVBORw0KGgoAAAANSUhEUgAAABQAAAAFCAYAAABFA8wzAAAACXBIWXMAAAsTAAALEwEAmpwYAAAA0ElEQVR42m1Q2W7DMAzz///gsD0tbZKuc47FV23n4EQNGYZiAgQbMkWTNI+U0LZX9H2HJPcYApxzGMcByzIj5wdYtVbM84SuaxGCV8w5a5p3DIPFtm0wOWdZXOCkCeDQWov7/QPzNMF7p4TEkex26zHYT5RSdB5jkP0vBO+x7zsMnuo4Dm0CSVJrkU9WbboJ4mBd11/sc5mT4HwkmD8yAqq0oialqNYuYu3t9QXXS6Px/BVwtvGb5FCyktAelXGZSmKMqpIx0OJPtqOenP1H+A1VCYNOiWe82wAAAABJRU5ErkJggg=='); background-size: cover; display: block;\"\n    >\n      <img\n        class=\"gatsby-resp-image-image\"\n        style=\"width: 100%; height: 100%; margin: 0; vertical-align: middle; position: absolute; top: 0; left: 0; box-shadow: inset 0px 0px 0px 400px white;\"\n        alt=\"Untitled\"\n        title=\"\"\n        src=\"/static/911c911a91f9bb20d324ad94526e6406/fcda8/1.png\"\n        srcset=\"/static/911c911a91f9bb20d324ad94526e6406/12f09/1.png 148w,\n/static/911c911a91f9bb20d324ad94526e6406/e4a3f/1.png 295w,\n/static/911c911a91f9bb20d324ad94526e6406/fcda8/1.png 590w,\n/static/911c911a91f9bb20d324ad94526e6406/efc66/1.png 885w,\n/static/911c911a91f9bb20d324ad94526e6406/146da/1.png 943w\"\n        sizes=\"(max-width: 590px) 100vw, 590px\"\n      />\n    </span>\n  </span>\n  \n  </a>\n    </p>\n<p>인터페이스를 클라이언트의 기대에 따라 분리함으로써 변경에 의해 영향을 제어하는 설계원칙을</p>\n<p><strong>인터페이스 분리 원칙</strong>이라고 부른다</p>\n<p>서브클래싱 : 다른 클래스의 코드를 재사용할 목적으로 상속을 사용하는 경우, 구현 상속 또는 클래스 상속이라도 부르기도 함.</p>\n<p>서브타이핑 : 타입계층을 구성하기 위해 상속을 사용하는 경우, 인터페이스 상속이라도 부르기도 함 </p>\n<h2 id=\"\"><a href=\"#\" aria-hidden class=\"anchor\"><svg aria-hidden=\"true\" height=\"16\" version=\"1.1\" viewBox=\"0 0 16 16\" width=\"16\"><path fill-rule=\"evenodd\" d=\"M4 9h1v1H4c-1.5 0-3-1.69-3-3.5S2.55 3 4 3h4c1.45 0 3 1.69 3 3.5 0 1.41-.91 2.72-2 3.25V8.59c.58-.45 1-1.27 1-2.09C10 5.22 8.98 4 8 4H4c-.98 0-2 1.22-2 2.5S3 9 4 9zm9-3h-1v1h1c1 0 2 1.22 2 2.5S13.98 12 13 12H9c-.98 0-2-1.22-2-2.5 0-.83.42-1.64 1-2.09V6.25c-1.09.53-2 1.84-2 3.25C6 11.31 7.55 13 9 13h4c1.45 0 3-1.69 3-3.5S14.5 6 13 6z\"></path></svg></a></h2>","timeToRead":4,"frontmatter":{"title":"오브젝트 - 13장 서브클래싱과 서브타이핑","date":"October 31, 2023","spoiler":"","cta":"object"},"fields":{"slug":"/object-13/","langKey":"en"}}},"pageContext":{"slug":"/object-13/","previous":{"fields":{"slug":"/object-11/","langKey":"en","directoryName":"object-11"},"frontmatter":{"title":"오브젝트 - 11장 합성과 유연한 설계"}},"next":{"fields":{"slug":"/object-15/","langKey":"en","directoryName":"object-15"},"frontmatter":{"title":"오브젝트 - 15장 디자인 패턴과 프레임워크"}},"translations":[],"translatedLinks":[]}},"staticQueryHashes":["336482444"]}